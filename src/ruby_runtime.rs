use std::sync::mpsc::{self, Receiver, Sender};
use std::thread;
use std::process::{Command, Stdio, Child};
use std::io::{BufRead, BufReader, Write, BufWriter};
use std::sync::{Arc, Mutex};
use evdev::InputEvent;
use serde::{Serialize, Deserialize};
use std::time::{SystemTime, UNIX_EPOCH};
use nix::unistd::{Uid, Gid, User, setuid, setgid, getuid};
use std::env;
use std::os::unix::process::CommandExt;

/// Physical input events from hardware
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PhysicalEvent {
  pub event_type: u16,
  pub code: u16,
  pub value: i32,
  pub timestamp_sec: u64,
  pub timestamp_nsec: u32,
}

impl From<InputEvent> for PhysicalEvent {
  fn from(event: InputEvent) -> Self {
    let duration = event.timestamp().duration_since(UNIX_EPOCH).unwrap_or_default();
    PhysicalEvent {
      event_type: event.event_type().0,
      code: event.code(),
      value: event.value(),
      timestamp_sec: duration.as_secs(),
      timestamp_nsec: duration.subsec_nanos(),
    }
  }
}

/// Synthetic events generated by Ruby scripts
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SyntheticEvent {
  pub event_type: u16,
  pub code: u16,
  pub value: i32,
}

/// State query requests from Ruby to Rust
#[derive(Debug, Serialize, Deserialize)]
pub enum StateQuery {
  KeyState(u16),
  ModifierState,
  DeviceConnected,
}

/// State query responses from Rust to Ruby
#[derive(Debug, Serialize, Deserialize)]
pub enum StateResponse {
  KeyState(bool),
  ModifierState(Vec<u16>),
  DeviceConnected(bool),
}

/// Ruby interpreter service with async event processing
pub struct RubyService {
  event_sender: Sender<PhysicalEvent>,
  synthetic_receiver: Arc<Mutex<Receiver<SyntheticEvent>>>,
  script_sender: Sender<ScriptCommand>,
  state_handler: Arc<dyn Fn(StateQuery) -> StateResponse + Send + Sync>,
  ruby_process: Option<Child>,
}

/// Embedded Ruby scripts at compile time
struct EmbeddedScripts;

impl EmbeddedScripts {
  fn get_script(name: &str) -> Option<&'static str> {
    match name {
      "eat_input" => Some(include_str!("../examples/ruby_scripts/eat_input.rb")),
      "propagate_input" => Some(include_str!("../examples/ruby_scripts/propagate_input.rb")),
      "alt_tab_combo" => Some(include_str!("../examples/ruby_scripts/alt_tab_combo.rb")),
      _ => None,
    }
  }
}

/// Script management commands
#[derive(Debug)]
pub enum ScriptCommand {
  LoadScript { name: String, path: String },
  LoadEmbeddedScript { name: String },
}

/// Determine the target user for Ruby script execution
fn get_target_user() -> Result<(Uid, Gid), Box<dyn std::error::Error>> {
  // If running as root, try to get the original user from SUDO_USER
  if let Ok(sudo_user) = env::var("SUDO_USER") {
    if let Ok(Some(user)) = User::from_name(&sudo_user) {
      return Ok((user.uid, user.gid));
    }
  }

  return Ok((getuid(), nix::unistd::getgid()));
}

/// Legacy compatibility types for existing code
#[derive(Clone, Debug)]
pub enum Action {
  Press(u16),
  PressDown(Vec<u16>),
  Release(u16),
}

#[derive(Clone, Debug)]
pub struct RubyEvent {
  pub key_code: Option<u16>,
  pub value: i32,
}

#[derive(Debug)]
pub struct Response {
  pub consume: bool,
  pub actions: Vec<Action>,
}

impl RubyService {
  pub fn new<F>(state_handler: F) -> Result<RubyService, Box<dyn std::error::Error>>
  where
    F: Fn(StateQuery) -> StateResponse + Send + Sync + 'static,
  {
    let (event_sender, event_receiver) = mpsc::channel::<PhysicalEvent>();
    let (synthetic_sender, synthetic_receiver) = mpsc::channel::<SyntheticEvent>();
    let (script_sender, script_receiver) = mpsc::channel::<ScriptCommand>();

    let synthetic_receiver = Arc::new(Mutex::new(synthetic_receiver));
    let state_handler = Arc::new(state_handler);

    // Spawn Ruby interpreter process with event loop
    let ruby_process = Self::spawn_ruby_process(
      event_receiver,
      synthetic_sender,
      script_receiver,
      state_handler.clone(),
    )?;

    Ok(RubyService {
      event_sender,
      synthetic_receiver,
      script_sender,
      state_handler,
      ruby_process: Some(ruby_process),
    })
  }

  fn spawn_ruby_process(
    event_receiver: Receiver<PhysicalEvent>,
    synthetic_sender: Sender<SyntheticEvent>,
    script_receiver: Receiver<ScriptCommand>,
    state_handler: Arc<dyn Fn(StateQuery) -> StateResponse + Send + Sync>,
  ) -> Result<Child, Box<dyn std::error::Error>> {
    // Embed the Ruby event loop script at compile time
    const EVENT_LOOP_SCRIPT: &str = include_str!("../ruby/event_loop.rb");

    // Create a temporary file with the embedded script content
    let temp_file = std::env::temp_dir().join("makita_event_loop.rb");
    std::fs::write(&temp_file, EVENT_LOOP_SCRIPT)?;

    // Get target user for privilege dropping
    let (target_uid, target_gid) = get_target_user()?;

    // Spawn Ruby process with the temporary script file and drop privileges
    let mut child = unsafe {
      Command::new("ruby")
        .arg(&temp_file)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .pre_exec(move || {
          // Drop privileges before executing Ruby
          if getuid().is_root() {
            // Set supplementary groups first
            if let Err(e) = nix::unistd::setgroups(&[target_gid]) {
              eprintln!("Failed to set supplementary groups: {}", e);
            }
            // Set group ID
            if let Err(e) = setgid(target_gid) {
              eprintln!("Failed to set GID: {}", e);
              return Err(std::io::Error::new(std::io::ErrorKind::PermissionDenied, "Failed to drop group privileges"));
            }
            // Set user ID (must be last)
            if let Err(e) = setuid(target_uid) {
              eprintln!("Failed to set UID: {}", e);
              return Err(std::io::Error::new(std::io::ErrorKind::PermissionDenied, "Failed to drop user privileges"));
            }
            println!("Ruby process will run as UID {} GID {}", target_uid, target_gid);
          }
          Ok(())
        })
        .spawn()?
    };

    let stdin = child.stdin.take().ok_or("Failed to get Ruby process stdin")?;
    let stdout = child.stdout.take().ok_or("Failed to get Ruby process stdout")?;
    let stderr = child.stderr.take().ok_or("Failed to get Ruby process stderr")?;

    let stdin = Arc::new(Mutex::new(BufWriter::new(stdin)));
    let stdin_clone: Arc<Mutex<BufWriter<std::process::ChildStdin>>> = Arc::clone(&stdin);

    // Thread to send events to Ruby process
    thread::spawn(move || {
      while let Ok(event) = event_receiver.recv() {
        if let Ok(mut writer) = stdin_clone.lock() {
          let json_event = serde_json::to_string(&event).unwrap_or_default();
          let _ = writeln!(writer, "EVENT:{}", json_event);
          let _ = writer.flush();
        }
      }
    });

    // Thread to handle script loading commands
    let stdin_clone2: Arc<Mutex<BufWriter<std::process::ChildStdin>>> = Arc::clone(&stdin);
    thread::spawn(move || {
      while let Ok(command) = script_receiver.recv() {
        if let Ok(mut writer) = stdin_clone2.lock() {
          match command {
            ScriptCommand::LoadScript { name, path } => {
              let _ = writeln!(writer, "LOAD:{}:{}", name, path);
              let _ = writer.flush();
            }
            ScriptCommand::LoadEmbeddedScript { name } => {
              if let Some(script_content) = EmbeddedScripts::get_script(&name) {
                // Create a temporary file with the embedded script content
                let temp_file = std::env::temp_dir().join(format!("makita_script_{}.rb", name));
                if let Ok(_) = std::fs::write(&temp_file, script_content) {
                  let _ = writeln!(writer, "LOAD:{}:{}", name, temp_file.to_string_lossy());
                  let _ = writer.flush();
                }
              }
            }
          }
        }
      }
    });

    // Thread to receive synthetic events and state queries from Ruby process
    let stdout_reader = BufReader::new(stdout);
    thread::spawn(move || {
      for line in stdout_reader.lines() {
        if let Ok(line) = line {
          if line.starts_with("SYNTHETIC:") {
            let json = &line[10..];
            if let Ok(event) = serde_json::from_str::<SyntheticEvent>(json) {
              let _ = synthetic_sender.send(event);
            }
          } else if line.starts_with("STATE:") {
            let json = &line[6..];
            if let Ok(query) = serde_json::from_str::<StateQuery>(json) {
              let _response = state_handler(query);
              // TODO: Send response back to Ruby process
            }
          } else if line.starts_with("READY") {
            println!("Ruby event loop is ready");
          } else if line.starts_with("LOADED:") {
            let script_name = &line[7..];
            println!("Ruby script loaded: {}", script_name);
          } else if line.starts_with("ERROR:") {
            eprintln!("Ruby error: {}", &line[6..]);
          } else if line.starts_with("CONSUME:") {
            let script_name = &line[8..];
            println!("Event consumed by script: {}", script_name);
          }
        }
      }
    });

    // Thread to handle stderr
    let stderr_reader = BufReader::new(stderr);
    thread::spawn(move || {
      for line in stderr_reader.lines() {
        if let Ok(line) = line {
          eprintln!("Ruby stderr: {}", line);
        }
      }
    });

    Ok(child)
  }

  /// Load a Ruby script into the interpreter
  pub fn load_script(&self, name: String, path: String) -> Result<(), Box<dyn std::error::Error>> {
    self.script_sender.send(ScriptCommand::LoadScript { name, path })?;
    Ok(())
  }

  /// Send a physical event to Ruby for processing (async)
  pub fn send_event(&self, event: PhysicalEvent) -> Result<(), Box<dyn std::error::Error>> {
    self.event_sender.send(event)?;
    Ok(())
  }

  /// Receive synthetic events generated by Ruby scripts (non-blocking)
  pub fn receive_synthetic_events(&self) -> Vec<SyntheticEvent> {
    let mut events = Vec::new();
    if let Ok(receiver) = self.synthetic_receiver.lock() {
      while let Ok(event) = receiver.try_recv() {
        events.push(event);
      }
    }
    events
  }

  /// Handle state query from Ruby (should be fast)
  pub fn handle_state_query(&self, query: StateQuery) -> StateResponse {
    (self.state_handler)(query)
  }

  /// Legacy compatibility method for existing code
  pub fn call_script(&self, script_name: String, ev: RubyEvent) -> Response {
    // Convert RubyEvent to PhysicalEvent and send
    let physical_event = PhysicalEvent {
      event_type: 1, // EV_KEY
      code: ev.key_code.unwrap_or(0),
      value: ev.value,
      timestamp_sec: SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
      timestamp_nsec: 0,
    };

    let _ = self.send_event(physical_event);

    // For compatibility, return empty response
    // In the new system, events are processed asynchronously
    Response {
      consume: false,
      actions: vec![],
    }
  }
}

impl Drop for RubyService {
  fn drop(&mut self) {
    if let Some(mut process) = self.ruby_process.take() {
      let _ = process.kill();
      let _ = process.wait();
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_physical_event_from_input_event() {
    use evdev::{EventType, InputEvent};
    use std::time::SystemTime;

    let input_event = InputEvent::new(EventType::KEY, 30, 1); // KEY_A press
    let physical_event = PhysicalEvent::from(input_event);

    assert_eq!(physical_event.event_type, 1); // EV_KEY
    assert_eq!(physical_event.code, 30); // KEY_A
    assert_eq!(physical_event.value, 1); // Press
  }

  #[test]
  fn test_ruby_service_creation() {
    let service = RubyService::new(|query| match query {
      StateQuery::KeyState(_) => StateResponse::KeyState(false),
      StateQuery::ModifierState => StateResponse::ModifierState(vec![]),
      StateQuery::DeviceConnected => StateResponse::DeviceConnected(true),
    });

    assert!(service.is_ok());
  }
}
