#!/bin/bash

# Makita Device Configuration Helper
# This script helps you create configuration files for your input devices

set -e

USER_NAME="${SUDO_USER:-$USER}"
USER_HOME="${SUDO_HOME:-$HOME}"
CONFIG_DIR="$USER_HOME/.config/makita"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

list_devices() {
    print_status "Available input devices:"
    echo

    if command -v evtest &> /dev/null; then
        # Use evtest to list devices
        sudo evtest | grep -E "^/dev/input/event[0-9]+" | while read -r line; do
            event_path=$(echo "$line" | awk '{print $1}')
            device_name=$(echo "$line" | cut -d: -f2- | xargs)
            echo "  $event_path: $device_name"
        done
    else
        # Fallback to listing /dev/input devices
        for device in /dev/input/event*; do
            if [ -r "$device" ]; then
                device_name=$(udevadm info --name="$device" 2>/dev/null | grep -E "ID_INPUT_.*=1" | head -1 || echo "Unknown Device")
                echo "  $device: $device_name"
            fi
        done
    fi

    echo
}

get_device_name() {
    local event_device="$1"

    if [ ! -r "$event_device" ]; then
        print_error "Cannot access $event_device. Make sure you have proper permissions."
        return 1
    fi

    udevadm info --name="$event_device" 2>/dev/null | grep "ID_VENDOR\|ID_MODEL" | cut -d= -f2 | tr '\n' ' ' | xargs
}

create_basic_config() {
    local device_name="$1"
    local config_file="$CONFIG_DIR/${device_name}.toml"

    print_status "Creating basic configuration for: $device_name"

    mkdir -p "$CONFIG_DIR"

    cat > "$config_file" << EOF
# Configuration for: $device_name
# Generated by configure-device.sh

[bindings.remap]
# Example key remappings (uncomment to use):
# KEY_CAPSLOCK = "KEY_ESC"                    # Caps Lock -> Escape
# KEY_RIGHTALT = "KEY_RIGHTCTRL"              # Right Alt -> Right Ctrl
# KEY_LEFTMETA = "KEY_LEFTALT"                # Windows key -> Left Alt

# Key combinations (hold first key, press second):
# KEY_LEFTALT = { "KEY_TAB" = "KEY_RIGHTMETA" }  # Alt+Tab -> Windows key

[settings]
# Optional settings:
LAYOUT_SWITCHER = "KEY_SCROLLLOCK"           # Key to switch between layouts
CHAIN_ONLY = "true"                         # Only process modifier chains

# Controller/gamepad settings (if applicable):
# LSTICK = "cursor"                         # Left stick function: cursor/scroll
# RSTICK = "scroll"                         # Right stick function: cursor/scroll
# LSTICK_SENSITIVITY = 0                    # Left stick sensitivity
# RSTICK_SENSITIVITY = 0                    # Right stick sensitivity
# LSTICK_DEADZONE = 5                       # Left stick deadzone (0-128)
# RSTICK_DEADZONE = 5                       # Right stick deadzone (0-128)
# CURSOR_SPEED = 0                          # Cursor movement speed
# SCROLL_SPEED = 0                          # Scroll movement speed
EOF

    print_success "Configuration created: $config_file"
    print_status "Edit this file to customize your key mappings."
}

create_ruby_config() {
    local device_name="$1"
    local config_file="$CONFIG_DIR/${device_name}.toml"

    print_status "Creating Ruby script configuration for: $device_name"

    mkdir -p "$CONFIG_DIR"

    cat > "$config_file" << EOF
# Ruby-based configuration for: $device_name
# Generated by configure-device.sh
#
# This configuration uses fine-grained Ruby scripting for per-key input processing.
# Set the MAKITA_RUBY_SCRIPTS environment variable to your Ruby scripts directory.
# Default location: examples/ruby_scripts/

[rubies]
# Map individual keys to Ruby scripts (without .rb extension)
# Examples:
KEY_CAPSLOCK = "remap_to_esc"           # Custom caps lock to escape script
KEY_F1 = "eat_input"                    # Consume F1 key presses
KEY_F2 = "propagate_input"              # Pass F2 through normally
KEY_F3 = "alt_tab_combo"                # Generate Alt+Tab combo

# Key combinations with modifiers:
KEY_LEFTCTRL-KEY_F1 = "eat_input"       # Ctrl+F1 consumed
KEY_LEFTSHIFT-KEY_F2 = "alt_tab_combo"  # Shift+F2 generates Alt+Tab

# Note: Each script should define a handle(event) function
# See example scripts in your Ruby scripts directory

[settings]
# Standard settings still apply
LAYOUT_SWITCHER = "KEY_SCROLLLOCK"

# Environment variable setup:
# export MAKITA_RUBY_SCRIPTS="$USER_HOME/.config/makita/scripts"
# systemctl --user restart makita
EOF

    # Create example Ruby scripts if they don't exist
    local script_dir="$CONFIG_DIR/scripts"
    mkdir -p "$script_dir"

    # Create remap_to_esc.rb script
    if [ ! -f "$script_dir/remap_to_esc.rb" ]; then
        cat > "$script_dir/remap_to_esc.rb" << 'EOF'
# Remap any key to ESC
def handle(event)
  if event.key_down?
    Makita.press(Makita::KB_ESC)
    return nil  # Consume the original event
  end
end
EOF
        print_success "Created script: $script_dir/remap_to_esc.rb"
    fi

    # Create example.rb with comprehensive documentation
    if [ ! -f "$script_dir/example.rb" ]; then
        cat > "$script_dir/example.rb" << 'EOF'
# Example Ruby script for Makita fine-grained key processing
# This script demonstrates the structure and available functions

def handle(event)
  # Event properties:
  # - event.key: key code (nil if not a key event)
  # - event.key_down?: true if key is pressed down
  # - event.key_up?: true if key is released

  # Available functions:
  # - Makita.press(key_code): Press and release a key
  # - Makita.press_down(key1, key2, ...): Press keys down (don't release)
  # - Makita.release(key_code): Release a key

  # Key constants:
  # - Makita::KB_LALT, Makita::KB_LTAB, Makita::KB_ESC, Makita::KB_ENTER

  # Return values:
  # - return nil: consume the event (don't pass it through)
  # - return anything else or no return: pass the event through

  # Example: Just pass through the event
  # This is the default behavior when no return nil is specified
end
EOF
        print_success "Created script: $script_dir/example.rb"
    fi

    print_success "Ruby configuration created: $config_file"
    print_status "Example Ruby script available at: $script_dir/example.rb"
}

interactive_setup() {
    print_status "=== Makita Device Configuration ==="
    echo

    # Check if config directory exists
    if [ ! -d "$CONFIG_DIR" ]; then
        print_warning "Config directory doesn't exist. Run setup-arch.sh first."
        exit 1
    fi

    list_devices

    echo "Enter the event device path (e.g., /dev/input/event0):"
    read -r event_device

    if [ ! -r "$event_device" ]; then
        print_error "Cannot access $event_device"
        print_status "Try running with sudo or check device permissions"
        exit 1
    fi

    device_name=$(get_device_name "$event_device")

    if [ -z "$device_name" ]; then
        print_error "Could not determine device name"
        exit 1
    fi

    print_status "Device name: $device_name"
    echo

    echo "Configuration type:"
    echo "1) Basic TOML configuration"
    echo "2) Ruby script configuration"
    echo "3) Both"
    echo
    echo "Choose (1-3):"
    read -r config_type

    case "$config_type" in
        1)
            create_basic_config "$device_name"
            ;;
        2)
            create_ruby_config "$device_name"
            ;;
        3)
            create_basic_config "$device_name"
            create_ruby_config "${device_name}-ruby"
            ;;
        *)
            print_error "Invalid choice"
            exit 1
            ;;
    esac

    echo
    print_success "Configuration setup complete!"
    print_status "Next steps:"
    echo "1. Edit the configuration files in: $CONFIG_DIR"
    echo "2. Test your configuration: sudo systemctl restart makita"
    echo "3. Check logs: journalctl -u makita -f"
}

show_help() {
    echo "Makita Device Configuration Helper"
    echo
    echo "Usage: $0 [OPTIONS]"
    echo
    echo "Options:"
    echo "  -l, --list      List available input devices"
    echo "  -d, --device    Configure specific device (interactive)"
    echo "  -h, --help      Show this help message"
    echo
    echo "Examples:"
    echo "  $0 --list                    # List all input devices"
    echo "  $0 --device                  # Interactive device configuration"
}

main() {
    case "${1:-}" in
        -l|--list)
            list_devices
            ;;
        -d|--device)
            interactive_setup
            ;;
        -h|--help|"")
            show_help
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
}

main "$@"
